# Задание

- Узнать какие бывают алгоритмы сортировки
- Сделать на каждый алгоритм отдельную функцию
- Сделать андроид-приложение в котором можно выбрать X(кол-во чисел в списке для сортировки), сами числа пусть будут рандомными, выбрать Y(алгоритм сортировки), отобразить время за которое произошла сортировка
- Поэкспериментировать на разных значениях, сравнить скорость
- Сравнить со скоростью стандартной функции сортировки
- Добавить в приложение выбор Z (выбор структуры данных списка чисел для сортировки)
- Написать в комментариях к приложению инструкцию для пользователя
- Написать в комментариях к приложению список самых быстрых алгоритмов, с указанием входных параметров

# Инструкция

 1) "Введите кол-во элементов" - введите кол-во элементов целым числом
 (При вводе если уже выбрана структура данных произойдет сброс и структуру надо выбрать заново)
 2) "Выбор структуры данных":
  - Array
  - ArrayLIst
  - LinkedList
 3) После выбора структуры Появятся:
  - "Через Thread" - выделите, если хотите делать сортировку через потоки
  - "Найти саммый быстрый алгоритм"(Займет некоторое время) - находит самый быстрый алгоритм
  - "Перемешать исходный массив" - перемешивает исходный массив
  - "Выберите метод сортировки" - выбор метода сортировки:
    - Пузырьковая сортировка
    - Сортировка выбором
    - Сортировка вставками
    - Быстрая сортировка
    - Стандартный алгоритм сортировки для данной структуры. При выборе метода сортировки в правом списке появится отсортированный массив
  - Список слева - исходная перемешенная структура данных
  - Список справа - отсортированный массив с указание времени работы в мс и названием алгоритма сортировки

Исходя из наблюдений сделаны следующие выводы:\
Для всех струткур самым быстрым являесятся стандартные алгоритмы сортировки\
При использовании потоков в большенсве случаем сортировка дольше\
Из использованных мной самым быстрым является быстрая сортировка, самым медленным пузырьковый\
Для **LinkedList** и **ArrayList** при кол-ве элементов>1000 **не рекомендуется** пузырьковый, так как слишком догое время работы и поиск быстрого алгоритма по этой же причине
